""" En este ejercicio controlaremos patrones a partir del uso de las flechas"""

import glfw
from OpenGL.GL import *
import numpy as np          # Necesitamos NumPy para manejar la matriz de bytes de forma eficiente
import time 

# Definición de los patrones para simular el movimiento
packman01 = np.array([0x00, 0x0f, 0xf0, 0x00, 0x00, 0x7f, 0xfe, 0x00,           
0x00, 0xff, 0xfe, 0x00, 0x03, 0xff, 0xfc, 0x00, 0x07, 0xff, 0xfc, 0x00,
0x0f, 0xff, 0xf8, 0x00, 0x1f, 0xff, 0xf8, 0x00, 0x3f, 0xff, 0xf0, 0x00,
0x3f, 0xff, 0xf0, 0x00, 0x7f, 0xff, 0xf0, 0x00, 0x7f, 0xff, 0xe0, 0x00,        
0x7f, 0xff, 0xc0, 0x00, 0xff, 0xff, 0xc0, 0x00, 0xff, 0xff, 0x80, 0x00,
0xff, 0xff, 0x80, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0xff, 0xff, 0xe0, 0x00,
0x7f, 0xf1, 0xe0, 0x00, 0x7f, 0xe0, 0xf0, 0x00, 0x7f, 0xe0, 0xf8, 0x00,
0x3f, 0xe0, 0xfc, 0x00, 0x3f, 0xf1, 0xfc, 0x00, 0x1f, 0xff, 0xfe, 0x00,
0x0f, 0xff, 0xff, 0x00, 0x07, 0xff, 0xff, 0x80, 0x03, 0xff, 0xff, 0x80,
0x01, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x0f, 0xe0, 0x00], dtype=np.ubyte)   

packman02 = np.array([0x00, 0x0f, 0xf0, 0x00, 0x00, 0x7f, 0xfe, 0x00,
0x00, 0xff, 0xff, 0x00, 0x03, 0xff, 0xff, 0xc0, 0x07, 0xff, 0xff, 0xe0,
0x0f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xe0, 0x3f, 0xff, 0xff, 0xc0,
0x3f, 0xff, 0xff, 0x80, 0x7f, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xfe, 0x00,
0x7f, 0xff, 0xfc, 0x00, 0xff, 0xff, 0xf0, 0x00, 0xff, 0xff, 0xe0, 0x00,
0xff, 0xff, 0xc0, 0x00, 0xff, 0xff, 0x80, 0x00, 0xff, 0xff, 0x80, 0x00,
0xff, 0xff, 0xe0, 0x00, 0xff, 0xff, 0xf0, 0x00, 0xff, 0xff, 0xfc, 0x00,
0x7f, 0xf1, 0xff, 0x00, 0x7f, 0xe0, 0xff, 0xc0, 0x7f, 0xe0, 0xff, 0xf0,
0x3f, 0xe0, 0xff, 0xfc, 0x3f, 0xf1, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0xf8,
0x0f, 0xff, 0xff, 0xf0, 0x07, 0xff, 0xff, 0xe0, 0x03, 0xff, 0xff, 0xc0,
0x01, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x0f, 0xe0, 0x00], dtype=np.ubyte)


packman03 = np.array([0x00, 0x0f, 0xf0, 0x00, 0x00, 0x7f, 0xfe, 0x00,
0x00, 0xff, 0xff, 0x80, 0x03, 0xff, 0xff, 0xc0, 0x07, 0xff, 0xff, 0xe0,
0x0f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xfc,
0x3f, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xfe,
0x7f, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xfe, 0x00,
0xff, 0xff, 0xf0, 0x00, 0xff, 0xff, 0xc0, 0x00, 0xff, 0xff, 0xc0, 0x00,
0xff, 0xff, 0xf8, 0x00, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xf8,
0x7f, 0xf1, 0xff, 0xfe, 0x7f, 0xe0, 0xff, 0xfe, 0x7f, 0xe0, 0xff, 0xfe,
0x3f, 0xe0, 0xff, 0xfc, 0x3f, 0xf1, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xf8,
0x0f, 0xff, 0xff, 0xf0, 0x07, 0xff, 0xff, 0xe0, 0x03, 0xff, 0xff, 0xc0,
0x01, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x0f, 0xe0, 0x00], dtype=np.ubyte)

packman04 = np.array([0x00, 0x0f, 0xf0, 0x00, 0x00, 0x7f, 0xfe, 0x00,
0x00, 0xff, 0xff, 0x80, 0x03, 0xff, 0xff, 0xc0, 0x07, 0xff, 0xff, 0xe0,
0x0f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xfc,
0x3f, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xfe,
0x7f, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0x7f, 0xf1, 0xff, 0xfe, 0x7f, 0xe0, 0xff, 0xfe, 0x7f, 0xe0, 0xff, 0xfe,
0x3f, 0xe0, 0xff, 0xfc, 0x3f, 0xf1, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xf8,
0x0f, 0xff, 0xff, 0xf0, 0x07, 0xff, 0xff, 0xe0, 0x03, 0xff, 0xff, 0xc0,
0x01, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x0f, 0xe0, 0x00 ], dtype=np.ubyte)


que_packman = [packman01, packman02, packman03, packman04, packman03, packman02]
que_patron = 0
pos_x = 2
pos_y = 30
inc_x = 0
inc_y = 0


def iniciar_ventana():
    if not glfw.init():
        raise Exception("No se pudo iniciar GLFW")
    ventana = glfw.create_window(400, 300, "glBitmap y glRasterPos2i", None, None)
    if not ventana:
        glfw.terminate()
        raise Exception("No se pudo crear la ventana")
    glfw.make_context_current(ventana)
    return ventana



def configurar_coordenadas_ventana(ancho, alto):
    """Configura la proyección para usar coordenadas de píxeles (ventana)."""
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    # glOrtho(left, right, bottom, top, near, far)
    # Esto mapea [0, ancho] en X y [0, alto] en Y
    glOrtho(0.0, ancho, 0.0, alto, -1.0, 1.0)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    # Nota: glRasterPos2i() funciona en coordenadas de ventana, 
    # por lo que es esencial configurar la proyección a coordenadas de ventana.



def captura_eventos_teclado(window, key, scancode, action, mods):

    global pos_x, pos_y, inc_x, inc_y

    if action == glfw.PRESS or action == glfw.REPEAT:
        if key == glfw.KEY_UP:          # Moviendo el packman hacia arriba
            inc_x = 0
            inc_y = 1
        elif key == glfw.KEY_DOWN:      # Moviendo el packman hacia abajo
            inc_x = 0
            inc_y = -1
        elif key == glfw.KEY_LEFT:      # Moviendo el packman hacia la izquierda
            inc_x = -1
            inc_y = 0
        elif key == glfw.KEY_RIGHT:     # Moviendo el packman hacia la derecha
            inc_x = 1
            inc_y = 0
        elif key == glfw.KEY_F1:        # Detenemos totalmente
            inc_x = 0
            inc_y = 0
        elif key == glfw.KEY_ESCAPE:    #  Control de la ventana (ESC = Salir)
            # Cierra la ventana cuando se presiona ESC
            glfw.set_window_should_close(window, True)



def dibujar_mapa_bits():
    """Función que usa glRasterPos2i() y glBitmap() para dibujar el patrón."""
    global pos_x, pos_y, inc_x, inc_y, que_patron
    
    # 1. Establecer el color para los píxeles encendidos (donde el bit es 1)
    glColor3f(1.0, 1.0, 0.0)  # Amarillo

    # 2. Establecer la posición de trama (Raster Position) en coordenadas de ventana
    # En este caso, usaremos coordenadas de ventana (píxeles), no las coordenadas -1 a 1 de OpenGL.
    glRasterPos2i(100, 100) # El mapa de bits empezará a dibujarse en el pixel (100, 100)
    
    # 3. Dibujar el mapa de bits
    # Parámetros: width, height, xorig, yorig, xmove, ymove, bitmap_data
    glBitmap( 
        32,             # Ancho del mapa de bits (en píxeles)
        32,             # Alto del mapa de bits (en píxeles)
        0.0, 0.0,       # Origen (usaremos el borde inferior izquierdo como origen)
        0.0, 0.0,       # No mover la posición de trama después de dibujar
        packman01       # El arreglo de bytes que contiene el patrón
    )

    glRasterPos2i(200, 100) # El mapa de bits empezará a dibujarse en el pixel (200, 100)
    glBitmap(32, 32, 0.0, 0.0, 0.0, 0.0, packman02)

    glRasterPos2i(300, 100) # El mapa de bits empezará a dibujarse en el pixel (300, 100)
    glBitmap(32, 32, 0.0, 0.0, 0.0, 0.0, packman03)

    glRasterPos2i(400, 100) # El mapa de bits empezará a dibujarse en el pixel (400, 100)
    glBitmap(32, 32, 0.0, 0.0, 0.0, 0.0, packman04)

    glRasterPos2i(pos_x,pos_y)
    glBitmap(32,32,0.0,0.0,0.0,0.0,que_packman[que_patron]);

    # print("Pos_x =", pos_x, "pos_y =", pos_y, "inc_x =", inc_x, "inc_y =", inc_y, "que_patron =", que_patron)

    #time.sleep(0.2)
    que_patron += 1
    if que_patron == 6:
        que_patron = 0

    pos_x += inc_x
    pos_y += inc_y
    
    if pos_x >= 500:
        pos_x = 2
    if pos_x <= 0:
        pos_x = 500
    if pos_y >= 500:
        pos_y = 2
    if pos_y <= 0:
        pos_y = 500



def main():
    ventana = iniciar_ventana()

    # Configurar la proyección para trabajar con coordenadas de píxeles
    configurar_coordenadas_ventana(500 , 500)
    glClearColor(0.0, 0.0, 0.2, 1.0) # Fondo azul oscuro

    glfw.set_key_callback(ventana, captura_eventos_teclado)

    while not glfw.window_should_close(ventana):
        glClear(GL_COLOR_BUFFER_BIT)
        
        # Llama a la función de dibujo de mapa de bits
        dibujar_mapa_bits()
        
        glfw.swap_buffers(ventana)
        glfw.poll_events()
    
    glfw.terminate()


if __name__ == "__main__":
    main()
    