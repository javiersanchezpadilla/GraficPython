import glfw
from OpenGL.GL import *
import numpy as np # Necesitamos NumPy para manejar la matriz de bytes de forma eficiente

# --- 1. Definición del Mapa de Bits ---
# Creamos un patrón binario de 32x32 que representa un "cuadrado" o patrón simple.
# Cada byte (GLubyte) representa 8 píxeles. Usamos '0xff' para 8 píxeles encendidos.
# Los datos deben estar en formato C-style (generalmente de abajo hacia arriba).
# Este arreglo representa un cuadrado simple o un patrón en la esquina.
BITMAP_WIDTH = 32
BITMAP_HEIGHT = 32

# Definición del patrón binario (8x8 píxeles)
# Por ejemplo: [0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF] (Un cuadro hueco)
# Usaremos un patrón más sencillo de 4x4 dentro de la matriz 8x8:

PackMan1 = np.array([0x00, 0x0f, 0xf0, 0x00, 0x00, 0x7f, 0xfe, 0x00,            # Fila 1 (Superior)
0x00, 0xff, 0xfe, 0x00, 0x03, 0xff, 0xfc, 0x00, 0x07, 0xff, 0xfc, 0x00,
0x0f, 0xff, 0xf8, 0x00, 0x1f, 0xff, 0xf8, 0x00, 0x3f, 0xff, 0xf0, 0x00,
0x3f, 0xff, 0xf0, 0x00, 0x7f, 0xff, 0xf0, 0x00, 0x7f, 0xff, 0xe0, 0x00,         # 0x0F -->  0000 1111
0x7f, 0xff, 0xc0, 0x00, 0xff, 0xff, 0xc0, 0x00, 0xff, 0xff, 0x80, 0x00,
0xff, 0xff, 0x80, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0xff, 0xff, 0xe0, 0x00,
0x7f, 0xf1, 0xe0, 0x00, 0x7f, 0xe0, 0xf0, 0x00, 0x7f, 0xe0, 0xf8, 0x00,
0x3f, 0xe0, 0xfc, 0x00, 0x3f, 0xf1, 0xfc, 0x00, 0x1f, 0xff, 0xfe, 0x00,
0x0f, 0xff, 0xff, 0x00, 0x07, 0xff, 0xff, 0x80, 0x03, 0xff, 0xff, 0x80,
0x01, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x0f, 0xe0, 0x00], dtype=np.ubyte)    # Fila 8 (Inferior)

PackMan2 = np.array([0x00, 0x0f, 0xf0, 0x00, 0x00, 0x7f, 0xfe, 0x00,
0x00, 0xff, 0xff, 0x00, 0x03, 0xff, 0xff, 0xc0, 0x07, 0xff, 0xff, 0xe0,
0x0f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xe0, 0x3f, 0xff, 0xff, 0xc0,
0x3f, 0xff, 0xff, 0x80, 0x7f, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xfe, 0x00,
0x7f, 0xff, 0xfc, 0x00, 0xff, 0xff, 0xf0, 0x00, 0xff, 0xff, 0xe0, 0x00,
0xff, 0xff, 0xc0, 0x00, 0xff, 0xff, 0x80, 0x00, 0xff, 0xff, 0x80, 0x00,
0xff, 0xff, 0xe0, 0x00, 0xff, 0xff, 0xf0, 0x00, 0xff, 0xff, 0xfc, 0x00,
0x7f, 0xf1, 0xff, 0x00, 0x7f, 0xe0, 0xff, 0xc0, 0x7f, 0xe0, 0xff, 0xf0,
0x3f, 0xe0, 0xff, 0xfc, 0x3f, 0xf1, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0xf8,
0x0f, 0xff, 0xff, 0xf0, 0x07, 0xff, 0xff, 0xe0, 0x03, 0xff, 0xff, 0xc0,
0x01, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x0f, 0xe0, 0x00], dtype=np.ubyte)


PackMan3 = np.array([0x00, 0x0f, 0xf0, 0x00, 0x00, 0x7f, 0xfe, 0x00,
0x00, 0xff, 0xff, 0x80, 0x03, 0xff, 0xff, 0xc0, 0x07, 0xff, 0xff, 0xe0,
0x0f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xfc,
0x3f, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xfe,
0x7f, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xfe, 0x00,
0xff, 0xff, 0xf0, 0x00, 0xff, 0xff, 0xc0, 0x00, 0xff, 0xff, 0xc0, 0x00,
0xff, 0xff, 0xf8, 0x00, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xf8,
0x7f, 0xf1, 0xff, 0xfe, 0x7f, 0xe0, 0xff, 0xfe, 0x7f, 0xe0, 0xff, 0xfe,
0x3f, 0xe0, 0xff, 0xfc, 0x3f, 0xf1, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xf8,
0x0f, 0xff, 0xff, 0xf0, 0x07, 0xff, 0xff, 0xe0, 0x03, 0xff, 0xff, 0xc0,
0x01, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x0f, 0xe0, 0x00], dtype=np.ubyte)

PackMan4 = np.array([0x00, 0x0f, 0xf0, 0x00, 0x00, 0x7f, 0xfe, 0x00,
0x00, 0xff, 0xff, 0x80, 0x03, 0xff, 0xff, 0xc0, 0x07, 0xff, 0xff, 0xe0,
0x0f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xfc,
0x3f, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xfe,
0x7f, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0x7f, 0xf1, 0xff, 0xfe, 0x7f, 0xe0, 0xff, 0xfe, 0x7f, 0xe0, 0xff, 0xfe,
0x3f, 0xe0, 0xff, 0xfc, 0x3f, 0xf1, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xf8,
0x0f, 0xff, 0xff, 0xf0, 0x07, 0xff, 0xff, 0xe0, 0x03, 0xff, 0xff, 0xc0,
0x01, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x0f, 0xe0, 0x00 ], dtype=np.ubyte)



def dibujar_mapa_bits():
    """Función que usa glRasterPos2i() y glBitmap() para dibujar el patrón."""
    
    # 1. Establecer el color para los píxeles encendidos (donde el bit es 1)
    glColor3f(1.0, 1.0, 0.0)  # Amarillo

    # 2. Establecer la posición de trama (Raster Position) en coordenadas de ventana
    # En este caso, usaremos coordenadas de ventana (píxeles), no las coordenadas -1 a 1 de OpenGL.
    glRasterPos2i(100, 100) # El mapa de bits empezará a dibujarse en el pixel (100, 100)
    
    # 3. Dibujar el mapa de bits
    # Parámetros: width, height, xorig, yorig, xmove, ymove, bitmap_data
    glBitmap(
        BITMAP_WIDTH,         # Ancho del mapa de bits (en píxeles)
        BITMAP_HEIGHT,        # Alto del mapa de bits (en píxeles)
        0.0, 0.0,             # Origen (usaremos el borde inferior izquierdo como origen)
        0.0, 0.0,             # No mover la posición de trama después de dibujar
        PackMan1           # El arreglo de bytes que contiene el patrón
    )

    glRasterPos2i(200, 100) # El mapa de bits empezará a dibujarse en el pixel (200, 100)
    glBitmap( BITMAP_WIDTH, BITMAP_HEIGHT, 0.0, 0.0, 0.0, 0.0, PackMan2)

    glRasterPos2i(300, 100) # El mapa de bits empezará a dibujarse en el pixel (300, 100)
    glBitmap( BITMAP_WIDTH, BITMAP_HEIGHT, 0.0, 0.0, 0.0, 0.0, PackMan3)

    glRasterPos2i(400, 100) # El mapa de bits empezará a dibujarse en el pixel (400, 100)
    glBitmap( BITMAP_WIDTH, BITMAP_HEIGHT, 0.0, 0.0, 0.0, 0.0, PackMan4)



def iniciar_ventana():
    if not glfw.init():
        raise Exception("No se pudo iniciar GLFW")
    ventana = glfw.create_window(800, 600, "glBitmap y glRasterPos2i", None, None)
    if not ventana:
        glfw.terminate()
        raise Exception("No se pudo crear la ventana")
    glfw.make_context_current(ventana)
    return ventana

def configurar_coordenadas_ventana(ancho, alto):
    """Configura la proyección para usar coordenadas de píxeles (ventana)."""
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    # glOrtho(left, right, bottom, top, near, far)
    # Esto mapea [0, ancho] en X y [0, alto] en Y
    glOrtho(0.0, ancho, 0.0, alto, -1.0, 1.0)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    # Nota: glRasterPos2i() funciona en coordenadas de ventana, 
    # por lo que es esencial configurar la proyección a coordenadas de ventana.


def main():
    ventana_ancho = 800
    ventana_alto = 600
    ventana = iniciar_ventana()

    # Configurar la proyección para trabajar con coordenadas de píxeles
    configurar_coordenadas_ventana(ventana_ancho, ventana_alto)
    
    glClearColor(0.0, 0.0, 0.2, 1.0) # Fondo azul oscuro
    
    while not glfw.window_should_close(ventana):
        glClear(GL_COLOR_BUFFER_BIT)
        
        # Llama a la función de dibujo de mapa de bits
        dibujar_mapa_bits()
        
        glfw.swap_buffers(ventana)
        glfw.poll_events()
    
    glfw.terminate()


if __name__ == "__main__":
    main()